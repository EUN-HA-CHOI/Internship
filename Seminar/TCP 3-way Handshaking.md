## TCP 3-way Handshaking

TCP 3-way Handshaking 에 대해 공부 하기 전, 먼저 TCP 와 UDP 이 무엇이고 왜 이 둘을 비교해서 공부 해야 하는지 알아 보자.

### TCP/UDP
OSI 7계층이란, 통신이 일어나는 과정을 7단계로 정의한 국제 통신 표준 규약이다.
TCP 와 UDP 는 OSI 7계층들 중 TCP/IP 의 전송 계층에서 사용되는 대표적인 프로토콜이다. **전송 계층은 송신자와 수신자를 연결하는 통
신 서비스를 제공하는 계층이다. 즉, 데이터의 전달을 담당하며 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당한다. **

### TCP / UDP 차이점
둘의 가장 큰 차이는 TCP 는 연결형 프로토콜이고, UDP 는 비연결 지향형 프로토콜이다. TCP는 연결이 먼저 성공해야 데이터 송수신이
가능하며 데이터의 손실, 오류, 삭제 등에 대해 데이터 재전송이 가능하며 데이터 손실을 방지할 수 있다.

ð 연결 지향성 프로토콜 이라는 것은 통신을 시작하기 전에 상대방과의 연결 상태를 확인하고, 통신이 종료되기 전까지 그 접속을 유지
하는 것이다. 그렇기 때문에 데이터전달 순서를 보장해주고, 데이터가 정확히 전달되는 것을 보장해준다. 송신측에서 A-B-C 라는 데이터
를보내게 되면 수신측에서는 A-B-C 의 순서대로 데이터를 전달받게 된다.

ð 이러한 특징 때문에 TCP는 신뢰성 있는 데이터 전송(데이터 손실되면 안되는)이 필요한 어플리케이션에 사용된다.
UDP의 경우에는 연결이 되어 있는지 확인하는 작업이 없다. 그렇기에 일방적으로 데이터를 전달한다. 또한 데이터 재전송이 없다.

ð 비연결성 프로토콜의 경우는 패킷이 어떤 경로로 전달될지도 알 수가 없고, 또한 패킷이 도착하지 않을 수도 있다.

ð 연결, 데이터 손실 확인 등을 위한 header 정보도 적고 연결 확인 작업도 없기 때문에 좀 더 빠르게 데이터 전송이 필요한 어플리케이션
에서 사용한다. (실시간 서비스)

즉, TCP 에서는 A-B-C 순서로 보내면 A-B-C 순서로 데이터를 받지만, UDP 에서는 A-C-B, A-A 와 같은 식으로도 데이터를 받을 수 있다는
것이다. 하지만 그대신 TCP에 비해서 속도가 훨씬 빠르고 훨씬 적은 오버헤드가 생긴다. 그래서 TCP 는 데이터의 신뢰성이 아주 중요할
경우에, UDP 는 데이터의 신뢰성이 별로 중요하지 않을 때 사용하게 된다. 메일 전송 등은 TCP 를 이용하고, DNS 서비스는 주로 UDP를
이용하게 된다.

### 3 TCP 연결 과정
TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정 (파일 전송, 통신 할 때 먼저 수행 됨
이 과정을 거치고 나서 데이터 전달 되기 시작함)

Open 한 클라이언트가 SYN 를 보내고 SYN_SENT 상태로 대기한다. 서버는 SYN_RECEIVED 상태로 바꾸고 SYN 과 응답 ACK를 보낸다.
SYN과 응답 ACK를 받은 ESTABLISHED 상태로 변경하고 서버에게 응답 ACK를 보낸다. 응답 ACK를 받은 서버는 ESTABLISHED 상태
로 변경한다.

### 2 way handshake 는 안 되는가?
TCP는 양방향 연결이기 때문에 클라이언트가 서버에게 존재를 알리고 서버에서도 클라이언트에게 존재를 알리고 대답을 얻어야된다.
그렇기 때문에 총 4단계가 필요하며, 축약한 것이 3단계이다.

### SYN,ACK ?
SYN - 연결 확인을 보내는 무작위의 숫자 값
ACK - Client 혹은 Server 로부터 받은 SYN 에 1을 더해 SYN을 잘 받았다는 ACK

1.클라이언트는 임의의 시퀀스 번호가 있는 서버에 SYN(동기화) 패킷을 보낸다.
2.서버는 임의의 시퀀스 번호와 클라이언트의 시퀀스 번호를 확인하는 ACK 번호가 포함된 SYN-ACK 패킷을 다시 보낸다.
3.클라이언트는 서버에 ACK 번호를 보내 서버의 시퀀스 번호를 확인 한다.
4.양쪽 끝의 시퀀스 번호가 동기화 된다. 이제 양쪽 끝에서 독립적으로 데이터를 보내고 받을 수 있다.

![image](https://github.com/EUN-HA-CHOI/Internship/assets/97012561/def2eea7-199a-41a4-8b6c-73746b832988)
![image](https://github.com/EUN-HA-CHOI/Internship/assets/97012561/0ca2a8ca-0b13-4d43-865e-da2ed9047e60)

<hr>

### WireShark Filter
TCP 3 Way HandShake 만 캡쳐하는 필터 식을 분석하여 확인 함. (tcp.flags.syn==1)

처음 2개의 패킷(SYN 패킷 / SYN + ACK 패킷)은 (통신 전체과정에서) 오직 그 두개의 패킷만 SYN이 켜져있으니, 캡쳐하기 쉽다. 이 두개
의 패킷을 캡쳐하기 위해서는, 간단하게 tcp.flags.syn==1 을 사용하면 된다.

그러나 3번째 패킷은 오직 ACK 만 켜져있으므로, 핸드 셰이크 과정 이후의 모든 패킷들도 ACK가 켜져 있는 건 마찬가지이다. 그래서
tcp.flags.syn==1 필터링만 가지고 3번째 패킷까지만 캡쳐하는 것은 무리이다. 3 Way HandShake 과정의 3번째 패킷에서만 발견될 수 있는
값을 필터링 하는 것이다. 

3번째 패킷의 SEQ 값이 SYN 패킷보다 1 크다는 것을 알고 있다. SYN 패킷의 SEQ 값이 RANDOM 이라서 문제
가 있었지만, 다행히 와이어 샤크는 상대 SEQ 값을 제공한다.(이는 기본적으로 제공된다.) 이는 모든 SYN 패킷은 상대 SEQ 값인 0을 가지
게 됨을 의미하고, 3번째 패킷은 상대 SEQ값인 1을 가지게 됨을 의미한다. 그러므로 tcp.seq==1 필터를 사용하고, 3번째 패킷은
SYN+ACK 패킷 후에 오므로, 즉 상대적 SEQ 값과 더불어 ACK 값도 1일 것이므로 결론적으로 tcp.seq==1 and tcp.ack==1 필터를 사용하게 된다.
